PACKAGE_DIRECTIVE: i = 1   class = class org.jetbrains.kotlin.psi.KtPackageDirective (Kotlin reflection is not available)    text:
package scripts

ADD: ALWAYS_RETAINED_PSI_ELEMENT

IMPORT_LIST: i = 3   class = class org.jetbrains.kotlin.psi.KtImportList (Kotlin reflection is not available)    text:
import java.util.*

ADD: ALWAYS_RETAINED_PSI_ELEMENT

FUN: i = 5   class = class org.jetbrains.kotlin.psi.KtNamedFunction (Kotlin reflection is not available)    text:
fun main() {
    val input = Scanner(System.`in`).nextInt()

    val output1 = if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

    val b = 2
    val a = b + 1

    val output2 = when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

    if (a == 3) {
        println("3")
    } else {
        println("!3")
    }

    val array = intArrayOf(1, 2, 3)
    val filter = array.map {
        val k = it + 2
        it + 1
    }
    println("$output1\n$output2\n$filter")
}

ADD: CONTAINER

BLOCK: i = 5   class = class org.jetbrains.kotlin.psi.KtBlockExpression (Kotlin reflection is not available)    text:
{
    val input = Scanner(System.`in`).nextInt()

    val output1 = if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

    val b = 2
    val a = b + 1

    val output2 = when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

    if (a == 3) {
        println("3")
    } else {
        println("!3")
    }

    val array = intArrayOf(1, 2, 3)
    val filter = array.map {
        val k = it + 2
        it + 1
    }
    println("$output1\n$output2\n$filter")
}

ADD: CONTAINER

PROPERTY: i = 6   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val input = Scanner(System.`in`).nextInt()

ADD: SLICE_ELEMENT

PROPERTY: i = 8   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val output1 = if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

ADD: SLICE_ELEMENT

IF: i = 8   class = class org.jetbrains.kotlin.psi.KtIfExpression (Kotlin reflection is not available)    text:
if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

ADD: SLICE_ELEMENT

BLOCK: i = 8   class = class org.jetbrains.kotlin.psi.KtBlockExpression (Kotlin reflection is not available)    text:
{
        "zero"
    }

ADD: SLICE_ELEMENT

IF: i = 10   class = class org.jetbrains.kotlin.psi.KtIfExpression (Kotlin reflection is not available)    text:
if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

ADD: SLICE_ELEMENT

BLOCK: i = 10   class = class org.jetbrains.kotlin.psi.KtBlockExpression (Kotlin reflection is not available)    text:
{
        "even"
    }

ADD: SLICE_ELEMENT

STRING_TEMPLATE: i = 13   class = class org.jetbrains.kotlin.psi.KtStringTemplateExpression (Kotlin reflection is not available)    text:
"not even"

SKIP

PROPERTY: i = 16   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val b = 2

SKIP

PROPERTY: i = 17   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val a = b + 1

SKIP

PROPERTY: i = 19   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val output2 = when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

ADD: SLICE_ELEMENT

WHEN: i = 19   class = class org.jetbrains.kotlin.psi.KtWhenExpression (Kotlin reflection is not available)    text:
when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

ADD: SLICE_ELEMENT

WHEN_ENTRY: i = 20   class = class org.jetbrains.kotlin.psi.KtWhenEntry (Kotlin reflection is not available)    text:
input == 0 -> {
            "zero"
        }

SKIP

WHEN_ENTRY: i = 23   class = class org.jetbrains.kotlin.psi.KtWhenEntry (Kotlin reflection is not available)    text:
input % 2 == 0 -> {
            "even"
        }

ADD: SLICE_ELEMENT

STRING_TEMPLATE: i = 27   class = class org.jetbrains.kotlin.psi.KtStringTemplateExpression (Kotlin reflection is not available)    text:
"not even"

SKIP

IF: i = 31   class = class org.jetbrains.kotlin.psi.KtIfExpression (Kotlin reflection is not available)    text:
if (a == 3) {
        println("3")
    } else {
        println("!3")
    }

SKIP

PROPERTY: i = 37   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val array = intArrayOf(1, 2, 3)

ADD: SLICE_ELEMENT

PROPERTY: i = 38   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val filter = array.map {
        val k = it + 2
        it + 1
    }

ADD: SLICE_ELEMENT

LAMBDA_EXPRESSION: i = 38   class = class org.jetbrains.kotlin.psi.KtLambdaExpression (Kotlin reflection is not available)    text:
{
        val k = it + 2
        it + 1
    }

ADD: SLICE_ELEMENT

BLOCK: i = 39   class = class org.jetbrains.kotlin.psi.KtBlockExpression (Kotlin reflection is not available)    text:
val k = it + 2
        it + 1

ADD: CONTAINER

PROPERTY: i = 39   class = class org.jetbrains.kotlin.psi.KtProperty (Kotlin reflection is not available)    text:
val k = it + 2

SKIP

BINARY_EXPRESSION: i = 40   class = class org.jetbrains.kotlin.psi.KtBinaryExpression (Kotlin reflection is not available)    text:
it + 1

ADD: SLICE_ELEMENT


==========SLICE ELEMENTS==========

PACKAGE_DIRECTIVE:
 package scripts

IMPORT_LIST:
 import java.util.*

FUN:
 fun main() {
    val input = Scanner(System.`in`).nextInt()

    val output1 = if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

    val b = 2
    val a = b + 1

    val output2 = when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

    if (a == 3) {
        println("3")
    } else {
        println("!3")
    }

    val array = intArrayOf(1, 2, 3)
    val filter = array.map {
        val k = it + 2
        it + 1
    }
    println("$output1\n$output2\n$filter")
}

BLOCK:
 {
    val input = Scanner(System.`in`).nextInt()

    val output1 = if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

    val b = 2
    val a = b + 1

    val output2 = when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

    if (a == 3) {
        println("3")
    } else {
        println("!3")
    }

    val array = intArrayOf(1, 2, 3)
    val filter = array.map {
        val k = it + 2
        it + 1
    }
    println("$output1\n$output2\n$filter")
}

PROPERTY:
 val input = Scanner(System.`in`).nextInt()

PROPERTY:
 val output1 = if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

IF:
 if (input == 0) {
        "zero"
    } else if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

BLOCK:
 {
        "zero"
    }

IF:
 if (input % 2 == 0) {
        "even"
    } else {
        "not even"
    }

BLOCK:
 {
        "even"
    }

PROPERTY:
 val output2 = when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

WHEN:
 when {
        input == 0 -> {
            "zero"
        }
        input % 2 == 0 -> {
            "even"
        }
        else -> {
            "not even"
        }
    }

WHEN_ENTRY:
 input % 2 == 0 -> {
            "even"
        }

PROPERTY:
 val array = intArrayOf(1, 2, 3)

PROPERTY:
 val filter = array.map {
        val k = it + 2
        it + 1
    }

LAMBDA_EXPRESSION:
 {
        val k = it + 2
        it + 1
    }

BLOCK:
 val k = it + 2
        it + 1

BINARY_EXPRESSION:
 it + 1

